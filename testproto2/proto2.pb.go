// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto2.proto

package proto2

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Instrument int32

const (
	Instrument_Voice  Instrument = 0
	Instrument_Guitar Instrument = 1
	Instrument_Drum   Instrument = 2
)

var Instrument_name = map[int32]string{
	0: "Voice",
	1: "Guitar",
	2: "Drum",
}

var Instrument_value = map[string]int32{
	"Voice":  0,
	"Guitar": 1,
	"Drum":   2,
}

func (x Instrument) Enum() *Instrument {
	p := new(Instrument)
	*p = x
	return p
}

func (x Instrument) String() string {
	return proto.EnumName(Instrument_name, int32(x))
}

func (x *Instrument) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Instrument_value, data, "Instrument")
	if err != nil {
		return err
	}
	*x = Instrument(value)
	return nil
}

func (Instrument) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1f509089572db8e7, []int{0}
}

type Genre int32

const (
	Genre_Pop          Genre = 0
	Genre_Rock         Genre = 1
	Genre_Jazz         Genre = 2
	Genre_NintendoCore Genre = 3
	Genre_Indie        Genre = 4
	Genre_Punk         Genre = 5
	Genre_Dance        Genre = 6
)

var Genre_name = map[int32]string{
	0: "Pop",
	1: "Rock",
	2: "Jazz",
	3: "NintendoCore",
	4: "Indie",
	5: "Punk",
	6: "Dance",
}

var Genre_value = map[string]int32{
	"Pop":          0,
	"Rock":         1,
	"Jazz":         2,
	"NintendoCore": 3,
	"Indie":        4,
	"Punk":         5,
	"Dance":        6,
}

func (x Genre) Enum() *Genre {
	p := new(Genre)
	*p = x
	return p
}

func (x Genre) String() string {
	return proto.EnumName(Genre_name, int32(x))
}

func (x *Genre) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Genre_value, data, "Genre")
	if err != nil {
		return err
	}
	*x = Genre(value)
	return nil
}

func (Genre) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1f509089572db8e7, []int{1}
}

type Artist struct {
	Name                 *string     `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	Role                 *Instrument `protobuf:"varint,2,opt,name=Role,enum=proto2.Instrument,def=1" json:"Role,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Artist) Reset()         { *m = Artist{} }
func (m *Artist) String() string { return proto.CompactTextString(m) }
func (*Artist) ProtoMessage()    {}
func (*Artist) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f509089572db8e7, []int{0}
}
func (m *Artist) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Artist.Unmarshal(m, b)
}
func (m *Artist) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Artist.Marshal(b, m, deterministic)
}
func (m *Artist) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Artist.Merge(m, src)
}
func (m *Artist) XXX_Size() int {
	return xxx_messageInfo_Artist.Size(m)
}
func (m *Artist) XXX_DiscardUnknown() {
	xxx_messageInfo_Artist.DiscardUnknown(m)
}

var xxx_messageInfo_Artist proto.InternalMessageInfo

const Default_Artist_Role Instrument = Instrument_Guitar

func (m *Artist) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Artist) GetRole() Instrument {
	if m != nil && m.Role != nil {
		return *m.Role
	}
	return Default_Artist_Role
}

type Song struct {
	Name                 *string   `protobuf:"bytes,1,opt,name=Name,def=Type in a Name" json:"Name,omitempty"`
	Track                *uint64   `protobuf:"varint,2,opt,name=Track,def=1" json:"Track,omitempty"`
	Duration             *float64  `protobuf:"fixed64,3,opt,name=Duration,def=3.3" json:"Duration,omitempty"`
	Composer             []*Artist `protobuf:"bytes,4,rep,name=Composer" json:"Composer,omitempty"`
	Good                 *bool     `protobuf:"varint,5,opt,name=Good,def=1" json:"Good,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Song) Reset()         { *m = Song{} }
func (m *Song) String() string { return proto.CompactTextString(m) }
func (*Song) ProtoMessage()    {}
func (*Song) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f509089572db8e7, []int{1}
}
func (m *Song) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Song.Unmarshal(m, b)
}
func (m *Song) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Song.Marshal(b, m, deterministic)
}
func (m *Song) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Song.Merge(m, src)
}
func (m *Song) XXX_Size() int {
	return xxx_messageInfo_Song.Size(m)
}
func (m *Song) XXX_DiscardUnknown() {
	xxx_messageInfo_Song.DiscardUnknown(m)
}

var xxx_messageInfo_Song proto.InternalMessageInfo

const Default_Song_Name string = "Type in a Name"
const Default_Song_Track uint64 = 1
const Default_Song_Duration float64 = 3.3
const Default_Song_Good bool = true

func (m *Song) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return Default_Song_Name
}

func (m *Song) GetTrack() uint64 {
	if m != nil && m.Track != nil {
		return *m.Track
	}
	return Default_Song_Track
}

func (m *Song) GetDuration() float64 {
	if m != nil && m.Duration != nil {
		return *m.Duration
	}
	return Default_Song_Duration
}

func (m *Song) GetComposer() []*Artist {
	if m != nil {
		return m.Composer
	}
	return nil
}

func (m *Song) GetGood() bool {
	if m != nil && m.Good != nil {
		return *m.Good
	}
	return Default_Song_Good
}

type Album struct {
	Name                 *string   `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	Song                 []*Song   `protobuf:"bytes,2,rep,name=Song" json:"Song,omitempty"`
	Genre                *Genre    `protobuf:"varint,3,opt,name=Genre,enum=proto2.Genre,def=1" json:"Genre,omitempty"`
	Year                 *string   `protobuf:"bytes,4,opt,name=Year,def=2015" json:"Year,omitempty"`
	Producer             []string  `protobuf:"bytes,5,rep,name=Producer" json:"Producer,omitempty"`
	Mediocre             *bool     `protobuf:"varint,6,opt,name=Mediocre,def=1" json:"Mediocre,omitempty"`
	Rated                *bool     `protobuf:"varint,7,opt,name=Rated" json:"Rated,omitempty"`
	Epilogue             *string   `protobuf:"bytes,8,opt,name=Epilogue" json:"Epilogue,omitempty"`
	Likes                []bool    `protobuf:"varint,9,rep,name=Likes" json:"Likes,omitempty"`
	Stars                *int64    `protobuf:"varint,10,opt,name=Stars" json:"Stars,omitempty"`
	Serial               []float64 `protobuf:"fixed64,11,rep,name=Serial" json:"Serial,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Album) Reset()         { *m = Album{} }
func (m *Album) String() string { return proto.CompactTextString(m) }
func (*Album) ProtoMessage()    {}
func (*Album) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f509089572db8e7, []int{2}
}
func (m *Album) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Album.Unmarshal(m, b)
}
func (m *Album) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Album.Marshal(b, m, deterministic)
}
func (m *Album) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Album.Merge(m, src)
}
func (m *Album) XXX_Size() int {
	return xxx_messageInfo_Album.Size(m)
}
func (m *Album) XXX_DiscardUnknown() {
	xxx_messageInfo_Album.DiscardUnknown(m)
}

var xxx_messageInfo_Album proto.InternalMessageInfo

const Default_Album_Genre Genre = Genre_Rock
const Default_Album_Year string = "2015"
const Default_Album_Mediocre bool = true

func (m *Album) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Album) GetSong() []*Song {
	if m != nil {
		return m.Song
	}
	return nil
}

func (m *Album) GetGenre() Genre {
	if m != nil && m.Genre != nil {
		return *m.Genre
	}
	return Default_Album_Genre
}

func (m *Album) GetYear() string {
	if m != nil && m.Year != nil {
		return *m.Year
	}
	return Default_Album_Year
}

func (m *Album) GetProducer() []string {
	if m != nil {
		return m.Producer
	}
	return nil
}

func (m *Album) GetMediocre() bool {
	if m != nil && m.Mediocre != nil {
		return *m.Mediocre
	}
	return Default_Album_Mediocre
}

func (m *Album) GetRated() bool {
	if m != nil && m.Rated != nil {
		return *m.Rated
	}
	return false
}

func (m *Album) GetEpilogue() string {
	if m != nil && m.Epilogue != nil {
		return *m.Epilogue
	}
	return ""
}

func (m *Album) GetLikes() []bool {
	if m != nil {
		return m.Likes
	}
	return nil
}

func (m *Album) GetStars() int64 {
	if m != nil && m.Stars != nil {
		return *m.Stars
	}
	return 0
}

func (m *Album) GetSerial() []float64 {
	if m != nil {
		return m.Serial
	}
	return nil
}

func init() {
	proto.RegisterEnum("proto2.Instrument", Instrument_name, Instrument_value)
	proto.RegisterEnum("proto2.Genre", Genre_name, Genre_value)
	proto.RegisterType((*Artist)(nil), "proto2.Artist")
	proto.RegisterType((*Song)(nil), "proto2.Song")
	proto.RegisterType((*Album)(nil), "proto2.Album")
}

func init() { proto.RegisterFile("proto2.proto", fileDescriptor_1f509089572db8e7) }

var fileDescriptor_1f509089572db8e7 = []byte{
	// 482 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x52, 0x41, 0x6b, 0xdb, 0x30,
	0x18, 0xad, 0x62, 0xd9, 0x75, 0xbe, 0x66, 0xc1, 0x88, 0xb1, 0x89, 0x5e, 0x26, 0x72, 0x99, 0x17,
	0x58, 0x58, 0x5c, 0x76, 0xf1, 0xad, 0x34, 0x23, 0x74, 0x74, 0x25, 0x28, 0xa5, 0xb0, 0xa3, 0x66,
	0x8b, 0x22, 0x92, 0x48, 0x41, 0x96, 0x0f, 0xeb, 0x4f, 0xda, 0x0f, 0xd8, 0xef, 0x1b, 0x92, 0x1d,
	0xaf, 0x83, 0x9d, 0xec, 0xf7, 0xbe, 0x4f, 0x8f, 0xf7, 0x9e, 0x04, 0x93, 0xa3, 0x35, 0xce, 0x14,
	0x8b, 0xf0, 0x21, 0x49, 0x87, 0x66, 0x77, 0x90, 0x5c, 0x5b, 0xa7, 0x1a, 0x47, 0x08, 0xe0, 0x7b,
	0x71, 0x90, 0x14, 0x31, 0x94, 0x8f, 0x79, 0xf8, 0x27, 0x0b, 0xc0, 0xdc, 0xec, 0x25, 0x1d, 0x31,
	0x94, 0x4f, 0x0b, 0xb2, 0xe8, 0x25, 0x6e, 0x75, 0xe3, 0x6c, 0x7b, 0x90, 0xda, 0x95, 0xc9, 0xba,
	0x55, 0x4e, 0x58, 0x1e, 0xf6, 0x66, 0xbf, 0x10, 0xe0, 0xad, 0xd1, 0x4f, 0x64, 0xf6, 0x52, 0xac,
	0x9c, 0x3e, 0xfc, 0x3c, 0x4a, 0xa6, 0x34, 0x13, 0xcc, 0xb3, 0xbd, 0xf8, 0x5b, 0x88, 0x1f, 0xac,
	0xa8, 0x76, 0x41, 0x1d, 0x97, 0x68, 0xc9, 0x3b, 0x4c, 0xde, 0x41, 0xba, 0x6a, 0xad, 0x70, 0xca,
	0x68, 0x1a, 0x31, 0x94, 0xa3, 0x32, 0xba, 0x5a, 0x5c, 0xf1, 0x81, 0x24, 0x73, 0x48, 0x6f, 0xcc,
	0xe1, 0x68, 0x1a, 0x69, 0x29, 0x66, 0x51, 0x7e, 0x51, 0x4c, 0x4f, 0xd6, 0xba, 0x30, 0x7c, 0x98,
	0x13, 0x0a, 0x78, 0x6d, 0x4c, 0x4d, 0x63, 0x86, 0xf2, 0xb4, 0xc4, 0xce, 0xb6, 0x92, 0x07, 0x66,
	0xf6, 0x7b, 0x04, 0xf1, 0xf5, 0xfe, 0x47, 0x7b, 0xf8, 0x6f, 0x74, 0xd6, 0x25, 0xa1, 0xa3, 0xa0,
	0x3f, 0x39, 0xe9, 0x7b, 0x8e, 0x77, 0x19, 0x3f, 0x40, 0xbc, 0x96, 0xda, 0xca, 0xe0, 0x71, 0x5a,
	0xbc, 0x3a, 0xad, 0x04, 0xb2, 0xc4, 0xdc, 0x54, 0x3b, 0xde, 0x6d, 0x78, 0x13, 0xdf, 0xa5, 0xf0,
	0x66, 0x7d, 0x1d, 0xb8, 0xf8, 0xb4, 0xfc, 0xcc, 0x03, 0x43, 0x2e, 0x21, 0xdd, 0x58, 0x53, 0xb7,
	0x95, 0xb4, 0x34, 0x66, 0x51, 0x3e, 0xe6, 0x03, 0x26, 0x0c, 0xd2, 0x6f, 0xb2, 0x56, 0xa6, 0xb2,
	0x92, 0x26, 0x2f, 0xec, 0x0f, 0x2c, 0x79, 0x0d, 0x31, 0x17, 0x4e, 0xd6, 0xf4, 0xdc, 0x8f, 0x79,
	0x07, 0xbc, 0xe6, 0x97, 0xa3, 0xda, 0x9b, 0xa7, 0x56, 0xd2, 0x34, 0x44, 0x1a, 0xb0, 0x3f, 0x71,
	0xa7, 0x76, 0xb2, 0xa1, 0x63, 0x16, 0xf9, 0x13, 0x01, 0x78, 0x76, 0xeb, 0x84, 0x6d, 0x28, 0x30,
	0x94, 0x47, 0xbc, 0x03, 0xe4, 0x0d, 0x24, 0x5b, 0x69, 0x95, 0xd8, 0xd3, 0x0b, 0x16, 0xe5, 0x88,
	0xf7, 0x68, 0xfe, 0x11, 0xe0, 0xef, 0x0b, 0x20, 0x63, 0x88, 0x1f, 0x8d, 0xaa, 0x64, 0x76, 0x46,
	0x00, 0xfa, 0xe7, 0x90, 0x21, 0x92, 0x02, 0x5e, 0xd9, 0xf6, 0x90, 0x8d, 0xe6, 0x8f, 0x7d, 0x4f,
	0xe4, 0x1c, 0xa2, 0x8d, 0x39, 0x66, 0x67, 0x7e, 0xe6, 0xdb, 0xe9, 0xb6, 0xbe, 0x8a, 0xe7, 0xe7,
	0x6c, 0x44, 0x32, 0x98, 0xdc, 0x2b, 0xed, 0xa4, 0xae, 0xcd, 0x8d, 0xb1, 0x32, 0x8b, 0xbc, 0xf0,
	0xad, 0xae, 0x95, 0xcc, 0xb0, 0x5f, 0xdb, 0xb4, 0x7a, 0x97, 0xc5, 0x9e, 0x5c, 0x09, 0x5d, 0xc9,
	0x2c, 0x29, 0x96, 0x90, 0x6c, 0x42, 0xe3, 0xe4, 0x3d, 0x9c, 0xf7, 0xa5, 0x91, 0xe1, 0x16, 0xc2,
	0xcd, 0x5e, 0xfe, 0x0b, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0x71, 0x83, 0x07, 0x4f, 0x04, 0x03,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Proto2Client is the client API for Proto2 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type Proto2Client interface {
	Produce(ctx context.Context, in *Album, opts ...grpc.CallOption) (*Album, error)
}

type proto2Client struct {
	cc *grpc.ClientConn
}

func NewProto2Client(cc *grpc.ClientConn) Proto2Client {
	return &proto2Client{cc}
}

func (c *proto2Client) Produce(ctx context.Context, in *Album, opts ...grpc.CallOption) (*Album, error) {
	out := new(Album)
	err := c.cc.Invoke(ctx, "/proto2.Proto2/Produce", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Proto2Server is the server API for Proto2 service.
type Proto2Server interface {
	Produce(context.Context, *Album) (*Album, error)
}

// UnimplementedProto2Server can be embedded to have forward compatible implementations.
type UnimplementedProto2Server struct {
}

func (*UnimplementedProto2Server) Produce(ctx context.Context, req *Album) (*Album, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Produce not implemented")
}

func RegisterProto2Server(s *grpc.Server, srv Proto2Server) {
	s.RegisterService(&_Proto2_serviceDesc, srv)
}

func _Proto2_Produce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Album)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Proto2Server).Produce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto2.Proto2/Produce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Proto2Server).Produce(ctx, req.(*Album))
	}
	return interceptor(ctx, in, info, handler)
}

var _Proto2_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto2.Proto2",
	HandlerType: (*Proto2Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Produce",
			Handler:    _Proto2_Produce_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto2.proto",
}
